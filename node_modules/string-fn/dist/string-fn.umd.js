(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.R = {}));
}(this, (function (exports) { 'use strict';

  function between(str, left, rightRaw) {
    const right = rightRaw === undefined ? left : rightRaw;
    const rightIndex = str.lastIndexOf(right);
    const leftIndex = str.indexOf(left);
    return rightIndex === -1 ? str : str.substring(leftIndex + left.length, rightIndex).trim();
  }

  const _isArray = Array.isArray;
  function type(input) {
    const typeOf = typeof input;
    if (input === null) {
      return 'Null';
    } else if (input === undefined) {
      return 'Undefined';
    } else if (typeOf === 'boolean') {
      return 'Boolean';
    } else if (typeOf === 'number') {
      return Number.isNaN(input) ? 'NaN' : 'Number';
    } else if (typeOf === 'string') {
      return 'String';
    } else if (_isArray(input)) {
      return 'Array';
    } else if (input instanceof RegExp) {
      return 'RegExp';
    }
    const asStr = input && input.toString ? input.toString() : '';
    if (['true', 'false'].includes(asStr)) return 'Boolean';
    if (!Number.isNaN(Number(asStr))) return 'Number';
    if (asStr.startsWith('async')) return 'Async';
    if (asStr === '[object Promise]') return 'Promise';
    if (typeOf === 'function') return 'Function';
    if (input instanceof String) return 'String';
    return 'Object';
  }
  function curry(fn, args = []) {
    return (..._args) => (rest => rest.length >= fn.length ? fn(...rest) : curry(fn, rest))([...args, ..._args]);
  }
  function parseError(maybeError) {
    const typeofError = maybeError.__proto__.toString();
    if (!['Error', 'TypeError'].includes(typeofError)) return [];
    return [typeofError, maybeError.message];
  }
  function parseDate(maybeDate) {
    if (!maybeDate.toDateString) return [false];
    return [true, maybeDate.getTime()];
  }
  function parseRegex(maybeRegex) {
    if (maybeRegex.constructor !== RegExp) return [false];
    return [true, maybeRegex.toString()];
  }
  function equals(a, b) {
    if (arguments.length === 1) return _b => equals(a, _b);
    const aType = type(a);
    if (aType !== type(b)) return false;
    if (['NaN', 'Undefined', 'Null'].includes(aType)) return true;
    if (aType === 'Number') {
      if (Object.is(-0, a) !== Object.is(-0, b)) return false;
      return a.toString() === b.toString();
    }
    if (['String', 'Boolean'].includes(aType)) {
      return a.toString() === b.toString();
    }
    if (aType === 'Array') {
      const aClone = Array.from(a);
      const bClone = Array.from(b);
      if (aClone.toString() !== bClone.toString()) {
        return false;
      }
      let loopArrayFlag = true;
      aClone.forEach((aCloneInstance, aCloneIndex) => {
        if (loopArrayFlag) {
          if (aCloneInstance !== bClone[aCloneIndex] && !equals(aCloneInstance, bClone[aCloneIndex])) {
            loopArrayFlag = false;
          }
        }
      });
      return loopArrayFlag;
    }
    const aRegex = parseRegex(a);
    const bRegex = parseRegex(b);
    if (aRegex[0]) {
      return bRegex[0] ? aRegex[1] === bRegex[1] : false;
    } else if (bRegex[0]) return false;
    const aDate = parseDate(a);
    const bDate = parseDate(b);
    if (aDate[0]) {
      return bDate[0] ? aDate[1] === bDate[1] : false;
    } else if (bDate[0]) return false;
    const aError = parseError(a);
    const bError = parseError(b);
    if (aError[0]) {
      return bError[0] ? aError[0] === bError[0] && aError[1] === bError[1] : false;
    }
    if (aType === 'Object') {
      const aKeys = Object.keys(a);
      if (aKeys.length !== Object.keys(b).length) {
        return false;
      }
      let loopObjectFlag = true;
      aKeys.forEach(aKeyInstance => {
        if (loopObjectFlag) {
          const aValue = a[aKeyInstance];
          const bValue = b[aKeyInstance];
          if (aValue !== bValue && !equals(aValue, bValue)) {
            loopObjectFlag = false;
          }
        }
      });
      return loopObjectFlag;
    }
    return false;
  }
  const _keys = Object.keys;
  function mapArray(fn, list, isIndexed = false) {
    let index = 0;
    const willReturn = Array(list.length);
    while (index < list.length) {
      willReturn[index] = isIndexed ? fn(list[index], index) : fn(list[index]);
      index++;
    }
    return willReturn;
  }
  function mapObject(fn, obj) {
    let index = 0;
    const keys = _keys(obj);
    const len = keys.length;
    const willReturn = {};
    while (index < len) {
      const key = keys[index];
      willReturn[key] = fn(obj[key], key, obj);
      index++;
    }
    return willReturn;
  }
  function map(fn, list) {
    if (arguments.length === 1) return _list => map(fn, _list);
    if (list === undefined) return [];
    if (_isArray(list)) return mapArray(fn, list);
    return mapObject(fn, list);
  }
  function merge(target, newProps) {
    if (arguments.length === 1) return _newProps => merge(target, _newProps);
    return Object.assign({}, target || {}, newProps || {});
  }
  function baseSlice(array, start, end) {
    let index = -1;
    let {
      length
    } = array;
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    const result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }
  function init(listOrString) {
    if (typeof listOrString === 'string') return listOrString.slice(0, -1);
    return listOrString.length ? baseSlice(listOrString, 0, -1) : [];
  }
  function test(pattern, str) {
    if (arguments.length === 1) return _str => test(pattern, _str);
    if (typeof pattern === 'string') {
      throw new TypeError(`‘test’ requires a value of type RegExp as its first argument; received "${pattern}"`);
    }
    return str.search(pattern) !== -1;
  }
  function toLower(str) {
    return str.toLowerCase();
  }
  function compose(...fns) {
    if (fns.length === 0) {
      throw new Error('compose requires at least one argument');
    }
    return (...args) => {
      const list = fns.slice();
      if (list.length > 0) {
        const fn = list.pop();
        let result = fn(...args);
        while (list.length > 0) {
          result = list.pop()(result);
        }
        return result;
      }
    };
  }
  function replaceFn(pattern, replacer, str) {
    return str.replace(pattern, replacer);
  }
  const replace$1 = curry(replaceFn);
  function sort(sortFn, list) {
    if (arguments.length === 1) return _list => sort(sortFn, _list);
    const clone = list.slice();
    return clone.sort(sortFn);
  }
  function partialCurry(fn, input) {
    return rest => {
      if (type(fn) === 'Async') {
        return new Promise((resolve, reject) => {
          fn(merge(rest, input)).then(resolve).catch(reject);
        });
      }
      return fn(merge(rest, input));
    };
  }
  function shuffle(arrayRaw) {
    const array = arrayRaw.concat();
    let counter = array.length;
    while (counter > 0) {
      const index = Math.floor(Math.random() * counter);
      counter--;
      const temp = array[counter];
      array[counter] = array[index];
      array[index] = temp;
    }
    return array;
  }
  const NO_MATCH_FOUND = Symbol ? Symbol('NO_MATCH_FOUND') : undefined;
  const getMatchingKeyValuePair = (cases, testValue, defaultValue) => {
    let iterationValue;
    for (let index = 0; index < cases.length; index++) {
      iterationValue = cases[index].test(testValue);
      if (iterationValue !== NO_MATCH_FOUND) {
        return iterationValue;
      }
    }
    return defaultValue;
  };
  const isEqual = (testValue, matchValue) => {
    const willReturn = typeof testValue === 'function' ? testValue(matchValue) : equals(testValue, matchValue);
    return willReturn;
  };
  const is = (testValue, matchResult = true) => ({
    key: testValue,
    test: matchValue => isEqual(testValue, matchValue) ? matchResult : NO_MATCH_FOUND
  });
  class Switchem {
    constructor(defaultValue, cases, willMatch) {
      if (cases === undefined && willMatch === undefined) {
        this.cases = [];
        this.defaultValue = undefined;
        this.willMatch = defaultValue;
      } else {
        this.cases = cases;
        this.defaultValue = defaultValue;
        this.willMatch = willMatch;
      }
      return this;
    }
    default(defaultValue) {
      const holder = new Switchem(defaultValue, this.cases, this.willMatch);
      return holder.match(this.willMatch);
    }
    is(testValue, matchResult) {
      return new Switchem(this.defaultValue, [...this.cases, is(testValue, matchResult)], this.willMatch);
    }
    match(matchValue) {
      return getMatchingKeyValuePair(this.cases, matchValue, this.defaultValue);
    }
  }
  function switcher(input) {
    return new Switchem(input);
  }
  function toDecimal(number, charsAfterDecimalPoint = 2) {
    return Number(parseFloat(String(number)).toFixed(charsAfterDecimalPoint));
  }
  function range(start, end) {
    if (arguments.length === 1) return _end => range(start, _end);
    if (Number.isNaN(Number(start)) || Number.isNaN(Number(end))) {
      throw new TypeError('Both arguments to range must be numbers');
    }
    if (end < start) return [];
    const len = end - start;
    const willReturn = Array(len);
    for (let i = 0; i < len; i++) {
      willReturn[i] = start + i;
    }
    return willReturn;
  }
  function reduceFn(reducer, acc, list) {
    if (!_isArray(list)) {
      throw new TypeError('reduce: list must be array or iterable');
    }
    let index = 0;
    const len = list.length;
    while (index < len) {
      acc = reducer(acc, list[index], index, list);
      index++;
    }
    return acc;
  }
  const reduce = curry(reduceFn);
  function drop(howManyToDrop, listOrString) {
    if (arguments.length === 1) return _list => drop(howManyToDrop, _list);
    return listOrString.slice(howManyToDrop > 0 ? howManyToDrop : 0);
  }
  function dropLast(howManyToDrop, listOrString) {
    if (arguments.length === 1) {
      return _listOrString => dropLast(howManyToDrop, _listOrString);
    }
    return howManyToDrop > 0 ? listOrString.slice(0, -howManyToDrop) : listOrString.slice();
  }
  function head(listOrString) {
    if (typeof listOrString === 'string') return listOrString[0] || '';
    return listOrString[0];
  }
  function join(glue, list) {
    if (arguments.length === 1) return _list => join(glue, _list);
    return list.join(glue);
  }
  function last(listOrString) {
    if (typeof listOrString === 'string') {
      return listOrString[listOrString.length - 1] || '';
    }
    return listOrString[listOrString.length - 1];
  }
  function length(x) {
    if (!x && x !== '' || x.length === undefined) {
      return NaN;
    }
    return x.length;
  }
  function match(pattern, input) {
    if (arguments.length === 1) return _input => match(pattern, _input);
    const willReturn = input.match(pattern);
    return willReturn === null ? [] : willReturn;
  }
  function multiply(x, y) {
    if (arguments.length === 1) return _y => multiply(x, _y);
    return x * y;
  }
  const product = reduce(multiply, 1);
  function split(separator, str) {
    if (arguments.length === 1) return _str => split(separator, _str);
    return str.split(separator);
  }
  function tail(listOrString) {
    return drop(1, listOrString);
  }
  function toUpper(str) {
    return str.toUpperCase();
  }
  function trim(str) {
    return str.trim();
  }

  const WORDS = /[A-Z]?[a-z]+|[A-Z]+(?![a-z])+/g;
  const WORDS_EXTENDED = /[A-Z\xC0-\xD6\xD8-\xDEА-Я]?[a-z\xDF-\xF6\xF8-\xFFа-я]+|[A-Z\xC0-\xD6\xD8-\xDE]+(?![a-z\xDF-\xF6\xF8-\xFF])/g;
  const PUNCTUATIONSX = /[",\.\?]/g;
  const PUNCTUATIONS = /[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,\-./:;<=>?@[\]^_`{|}~]/g;
  const HTML_TAGS = /<[^>]*>/g;

  function words(str) {
    return match(WORDS, str);
  }

  function wordsX(str) {
    return match(WORDS_EXTENDED, str);
  }

  function camelCase(str, extraLatin = false) {
    const method = extraLatin ? wordsX : words;
    const result = join('', map(val => `${toUpper(head(val))}${toLower(tail(val))}`, method(str)));
    return `${toLower(head(result))}${tail(result)}`;
  }

  function count(str, substr) {
    return length(split(substr, str)) - 1;
  }

  const constantCase = (str, extraLatin = false) => {
    const method = extraLatin ? wordsX : words;
    return compose(join('_'), map(toUpper), method)(str);
  };

  function distance(a, b) {
    if (a.length === 0) {
      return b.length;
    }

    if (b.length === 0) {
      return a.length;
    }

    let i, j, prev, tmp, val;

    if (a.length > b.length) {
      tmp = a;
      a = b;
      b = tmp;
    }

    const row = Array(a.length + 1);

    for (i = 0; i <= a.length; i++) {
      row[i] = i;
    }

    for (i = 1; i <= b.length; i++) {
      prev = i;

      for (j = 1; j <= a.length; j++) {
        if (b[i - 1] === a[j - 1]) {
          val = row[j - 1];
        } else {
          val = Math.min(row[j - 1] + 1, Math.min(prev + 1, row[j] + 1));
        }

        row[j - 1] = prev;
        prev = val;
      }

      row[a.length] = prev;
    }

    return row[a.length];
  }

  const normalizeGermanChar = char => {
    const arr = ['ä', 'ö', 'ü', 'ß'];
    const normalizedArr = ['a', 'o', 'u', 'ss'];
    const foundIndex = arr.indexOf(char);

    if (foundIndex === -1) {
      return char;
    }

    return normalizedArr[foundIndex];
  };

  const normalizeGermanWord = str => join('', map(val => normalizeGermanChar(val), split('', toLower(str))));

  function distanceGerman(a, b) {
    return distance(normalizeGermanWord(a), normalizeGermanWord(b));
  }

  function dotCase(str, extraLatin = false) {
    const method = extraLatin ? wordsX : words;
    return join('.', map(toLower, method(str)));
  }

  function glob(str, globStr) {
    const numGlobs = count(globStr, '*');

    if (numGlobs === 1) {
      if (head(globStr) === '*') {
        return str.endsWith(tail(globStr));
      } else if (last(globStr) === '*') {
        return str.startsWith(init(globStr));
      }
    } else if (numGlobs === 2 && head(globStr) === '*' && last(globStr) === '*') {
      globStr = init(tail(globStr));
      const foundIndex = str.indexOf(globStr);
      return foundIndex > 0 && foundIndex + globStr.length < str.length;
    }

    return false;
  }

  function getIndent(str) {
    const matched = str.match(/\w|\d/);
    if (matched === null) return str.length;
    return matched.index;
  }

  function indent(str, indentCount) {
    return join('\n', map(val => `${' '.repeat(indentCount)}${val}`, split('\n', str)));
  }

  function isLetter(char) {
    return test(WORDS_EXTENDED, char);
  }

  function isPunctuation(char) {
    return test(PUNCTUATIONS, char);
  }

  function kebabCase(str, extraLatin = false) {
    const method = extraLatin ? wordsX : words;
    return toLower(join('-', method(str)));
  }

  function trim$1(str) {
    return replace$1(/\s+/g, ' ', str).trim();
  }

  const humanLengths = {
    5: 'Five',
    6: 'Six',
    7: 'Seven',
    8: 'Eight'
  };
  const globs = {
    easyFive: '*123*',
    easySix: '*123**',
    easySixR: '**234*',
    easierSix: '*123**',
    easierSixR: '**234*',
    easySeven: '*1234**',
    easySevenR: '**2345*',
    easierSeven: '**234**',
    easyEight: '**2345**',
    easierEight: '**234***',
    easierEightR: '***345**',
    easyAny: len => `**${'-'.repeat(len - 5)}***`,
    easierAny: len => `***${'-'.repeat(len - 6)}***`
  };

  function chance() {
    return Math.random() > 0.49;
  }

  function getGlob(len, mode, random) {
    if (len > 8) return globs[`${mode}Any`](len);
    if (len === 5) return globs.easyFive;
    const base = `${mode}${humanLengths[len]}`;
    const maybeKey = globs[base];

    if (!random) {
      return maybeKey === undefined ? globs[`easy${humanLengths[len]}`] : maybeKey;
    }

    return globs[`${base}R`] === undefined ? maybeKey : chance() ? globs[`${base}R`] : maybeKey;
  }

  function ant(word, glob, replacer) {
    const chars = [...word];
    return chars.map((char, i) => glob[i] === '*' ? char : replacer).join('');
  }
  function maskWordHelper(word, replacer, charLimit = 4) {
    if (test(PUNCTUATIONSX, word) || word.length <= 1) {
      return word;
    }

    if (word.length < charLimit) {
      return `${head(word)}${replacer.repeat(word.length - 1)}`;
    }

    return `${head(word)}${replacer.repeat(word.length - 2)}${last(word)}`;
  }
  function maskWordHelperX({
    word,
    replacer = '_',
    easyMode = false,
    randomMode = false,
    easierMode = false,
    charLimit = 4
  }) {
    const len = word.length;
    if (!easyMode && !easierMode || len <= 4) return maskWordHelper(word, replacer, charLimit);
    const glob = getGlob(len, easyMode ? 'easy' : 'easier', randomMode);
    return ant(word, glob, replacer);
  }

  const addSpaceAroundPunctuation = sentence => sentence.replace(PUNCTUATIONSX, x => ` ${x} `);

  function maskSentence({
    charLimit = 4,
    easyMode = false,
    easierMode = false,
    randomMode = false,
    replacer = '_',
    sentence,
    words = []
  }) {
    const parsed = trim$1(addSpaceAroundPunctuation(sentence));
    const hidden = [];
    const visible = [];
    const input = {
      replacer,
      easyMode,
      randomMode,
      easierMode,
      charLimit
    };
    const easyFn = partialCurry(maskWordHelperX, input);
    const ant = easierMode || easyMode ? word => easyFn({
      word
    }) : word => maskWordHelper(word, replacer, charLimit);
    map(word => {
      const ok = words.length === 0 || words.includes(word);
      const visiblePart = ok ? ant(word) : word;
      hidden.push(word);
      visible.push(visiblePart);
    }, split(' ', parsed));
    return {
      hidden,
      visible
    };
  }

  function maskWords({
    words,
    replacer = '_',
    charLimit = 3
  }) {
    const result = map(val => maskWordHelper(val, replacer, charLimit), split(' ', words));
    return join(' ', result);
  }

  function parseInput(inputRaw) {
    if (typeof inputRaw !== 'string') throw new Error('inputRaw !== string');
    const numbers = [];
    const chars = [];
    let flag = false;
    inputRaw.split('').forEach(x => {
      if (flag && x) {
        chars.push(x);
      } else if (!flag) {
        const isNumber = Number(x) === Number(x);

        if (isNumber) {
          numbers.push(x);
        } else {
          chars.push(x);
          flag = true;
        }
      } else {
        flag = true;
      }
    });
    return {
      numbers: Number(numbers.join('')),
      chars: chars.join('')
    };
  }

  const hash = {
    1: ['s', 'seconds', 'second', 'sec'],
    60: ['m', 'minutes', 'minute', 'min'],
    3600: ['h', 'hours', 'hour'],
    86400: ['d', 'days', 'day']
  };

  function findInHash(hashKey) {
    const [found] = Object.keys(hash).filter(singleKey => hash[singleKey].includes(hashKey));
    if (!found) throw new Error('no numbers passed to `ms`');
    return found;
  }

  function ms(inputRaw) {
    const input = parseInput(inputRaw);
    const miliseconds = findInHash(input.chars);
    return Math.floor(Number(miliseconds) * 1000 * input.numbers);
  }

  const SECONDS = 'seconds';
  const MINUTES = 'minutes';
  const HOURS = 'hours';
  const DAYS = 'days';

  function findLargestUnit(seconds) {
    return switcher(seconds).is(x => x < 60, {
      label: SECONDS,
      scale: 1
    }).is(x => x < 3600, {
      label: MINUTES,
      scale: 60
    }).is(x => x < 3600 * 24 * 7, {
      label: HOURS,
      scale: 3600
    }).default({
      label: DAYS,
      scale: 3600 * 24
    });
  }

  function msToText(msInput) {
    if (typeof msInput !== 'number') {
      throw new Error(`${msInput} is not a number`);
    }

    const seconds = toDecimal(msInput / 1000, 0);
    const {
      label,
      scale
    } = findLargestUnit(seconds);
    return `${toDecimal(seconds / scale, 1)} ${label}`;
  }

  function pascalCase(str, extraLatin = false) {
    const method = extraLatin ? wordsX : words;
    return join('', map(val => `${toUpper(head(val))}${toLower(tail(val))}`, method(str)));
  }

  function removeIndent(str) {
    return join('\n', map(val => val.trimLeft(), split('\n', str)));
  }

  const charCodesString = [...range(65, 90), ...range(97, 122)];
  const charCodes = [...charCodesString, ...range(49, 57)];
  function randomString(length = 8, stringTag = false) {
    const loops = range(0, length);
    const charSet = stringTag ? charCodesString : charCodes;
    return loops.map(x => String.fromCharCode(head(shuffle(charSet)))).join('');
  }

  function reverse(str) {
    return [...str].reverse().join('');
  }

  function seoTitle(str, limit = 3) {
    const result = join(' ', map(val => {
      if (val.length >= limit) {
        return `${toUpper(head(val))}${toLower(tail(val))}`;
      }

      return val;
    }, words(str)));
    return `${toUpper(head(result))}${tail(result)}`;
  }

  const shuffleArr = arr => {
    let counter = arr.length;

    while (counter > 0) {
      const index = Math.floor(Math.random() * counter);
      counter--;
      const temp = arr[counter];
      arr[counter] = arr[index];
      arr[index] = temp;
    }

    return arr;
  };

  function shuffle$1(str) {
    return join('', shuffleArr(split('', str)));
  }

  function snakeCase(str, extraLatin = false) {
    const method = extraLatin ? wordsX : words;
    return toLower(join('_', method(str)));
  }

  function splitPerLine({
    text,
    perLine = 30,
    splitChar = ' '
  }) {
    const words = text.split(splitChar);
    const toReturn = [];
    let line = '';
    words.forEach(word => {
      const newLine = line + (line === '' ? '' : ' ') + word;

      if (newLine.length >= perLine) {
        toReturn.push(line);
        line = word;
      } else {
        line = newLine;
      }
    });

    if (line !== '') {
      toReturn.push(line);
    }

    return toReturn;
  }

  const addSpaceAroundPunctuation$1 = sentence => sentence.replace(PUNCTUATIONS, match => ` ${match} `);

  function splitSentence(sentence) {
    return split(' ', trim$1(addSpaceAroundPunctuation$1(sentence)));
  }

  function stripPunctuation(str) {
    return replace$1(PUNCTUATIONS, '', str);
  }

  const getMaxLength = lines => {
    const [max] = sort((a, b) => a.length < b.length ? 1 : -1)(lines);
    return max.length;
  };

  const BUFFER = 3;
  function fitWithinLines({
    limit,
    perLine = 30,
    text
  }) {
    let counter = perLine;
    const len = text.length;
    let answer;

    while (counter < len) {
      counter++;
      const maybeAnswer = splitPerLine({
        text,
        perLine: counter
      });

      if (maybeAnswer.length <= limit) {
        answer = maybeAnswer;
        counter = len;
      }
    }

    if (!answer) {
      const partial = trim(dropLast(BUFFER, text));

      if (partial.length < BUFFER * 2) {
        throw new Error(`such text cannot fit within ${limit} lines`);
      }

      return fitWithinLines({
        text: partial,
        perLine,
        limit
      });
    }

    return answer;
  }

  function stripTags(str) {
    return replace$1(/\s+/g, ' ', replace$1(HTML_TAGS, ' ', str)).trim();
  }

  function mergeAll(arr) {
    let willReturn = {};
    map(val => {
      willReturn = merge(willReturn, val);
    }, arr);
    return willReturn;
  }

  function mapToObject(fn, list) {
    return mergeAll(map(fn, list));
  }

  function takeArguments(url, sep = '?', rawFlag = false) {
    const [, ...rawArguments] = url.split(sep);
    if (rawArguments.length === 0) return {};
    return mapToObject(x => {
      const [keyRaw, value] = x.split('=');
      const key = rawFlag ? keyRaw : camelCase(keyRaw);

      if (value === undefined || value === 'true') {
        return {
          [key]: true
        };
      }

      if (value === 'false') {
        return {
          [key]: false
        };
      }

      if (Number.isNaN(Number(value))) {
        return {
          [key]: value
        };
      }

      return {
        [key]: Number(value)
      };
    }, rawArguments);
  }

  function titleCase(str, extraLatin = false) {
    const method = extraLatin ? wordsX : words;
    return join(' ', map(val => `${toUpper(head(val))}${toLower(tail(val))}`, method(str)));
  }

  exports.between = between;
  exports.camelCase = camelCase;
  exports.constantCase = constantCase;
  exports.count = count;
  exports.distance = distance;
  exports.distanceGerman = distanceGerman;
  exports.dotCase = dotCase;
  exports.fitWithinLines = fitWithinLines;
  exports.getIndent = getIndent;
  exports.getMaxLength = getMaxLength;
  exports.glob = glob;
  exports.indent = indent;
  exports.isLetter = isLetter;
  exports.isPunctuation = isPunctuation;
  exports.kebabCase = kebabCase;
  exports.maskSentence = maskSentence;
  exports.maskWords = maskWords;
  exports.ms = ms;
  exports.msToText = msToText;
  exports.pascalCase = pascalCase;
  exports.randomString = randomString;
  exports.removeIndent = removeIndent;
  exports.reverse = reverse;
  exports.seoTitle = seoTitle;
  exports.shuffle = shuffle$1;
  exports.snakeCase = snakeCase;
  exports.splitPerLine = splitPerLine;
  exports.splitSentence = splitSentence;
  exports.stripPunctuation = stripPunctuation;
  exports.stripTags = stripTags;
  exports.takeArguments = takeArguments;
  exports.titleCase = titleCase;
  exports.trim = trim$1;
  exports.words = words;
  exports.wordsX = wordsX;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
